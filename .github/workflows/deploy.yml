# .github/workflows/deploy.yml
name: Deploy to Production (Hetzner)

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure SSH access
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.HETZNER_SSH_KEY }}

      - name: Transfer files to server
        run: |
          rsync -rlptDzv \
            --delete \
            --exclude='.git' \
            --exclude='.github' \
            --exclude='.env*' \
            --exclude='node_modules' \
            --exclude='app_data' \
            --exclude='nginx/config/dhparam' \
            -e "ssh -o StrictHostKeyChecking=no" \
            "$GITHUB_WORKSPACE/" \
            "deploy@${{ secrets.HETZNER_SERVER_IP }}:/home/deploy/app/"

      - name: Handle DH params
        run: |
          ssh -T -o StrictHostKeyChecking=no deploy@${{ secrets.HETZNER_SERVER_IP }} << 'EOT'
          set -e
          cd /home/deploy/app
          
          # Create directory if it doesn't exist
          sudo mkdir -p nginx/config/dhparam
          sudo chown deploy:docker nginx/config/dhparam
          
          # Generate DH params if missing
          if [ ! -f "nginx/config/dhparam/dhparam.pem" ]; then
            sudo openssl dhparam -out nginx/config/dhparam/dhparam.pem 2048
            sudo chown deploy:docker nginx/config/dhparam/dhparam.pem
          fi
          
          # Set proper permissions
          sudo chmod 644 nginx/config/dhparam/dhparam.pem
          EOT

      - name: Create and secure .env file
        run: |
          ssh -T -o StrictHostKeyChecking=no deploy@${{ secrets.HETZNER_SERVER_IP }} << 'EOT'
          set -e
          cd /home/deploy/app

          cat <<EOF > .env
          DOMAIN=${{ secrets.PROD_DOMAIN }}
          DEBUG=false
          ENV=production
          EMAIL=${{ secrets.PROD_EMAIL }}

          TYPESENSE_API_KEY=${{ secrets.PROD_TYPESENSE_API_KEY }}
          TYPESENSE_HOST=typesense
          TYPESENSE_PORT=8108
          TYPESENSE_PROTOCOL=http
          TYPESENSE_DATA_DIR=/home/deploy/app_data/typesense

          PROD_BACKEND_PORT=8000
          PROD_FRONTEND_PORT=8001

          BACKEND_STARTUP_DELAY=30
          EOF

          chmod 640 .env
          chown deploy:docker .env
          EOT

      - name: Set up directories and permissions
        run: |
          ssh -T -o StrictHostKeyChecking=no deploy@${{ secrets.HETZNER_SERVER_IP }} << 'EOT'
          set -e
          cd /home/deploy/app

          sudo mkdir -p /home/deploy/app_data/{typesense,static,certbot/conf/live}
          sudo mkdir -p /home/deploy/app/nginx/config/dhparam
          sudo chown -R deploy:docker /home/deploy/app_data
          sudo chmod -R 775 /home/deploy/app_data

          if [ ! -f "/home/deploy/app/nginx/config/dhparam/dhparam.pem" ]; then
            sudo openssl dhparam -out /home/deploy/app/nginx/config/dhparam/dhparam.pem 2048
            sudo chown deploy:docker /home/deploy/app/nginx/config/dhparam/dhparam.pem
          fi
          EOT

      - name: Deploy services with proper dependency handling
        run: |
          ssh -T -o StrictHostKeyChecking=no deploy@${{ secrets.HETZNER_SERVER_IP }} << 'EOT'
          set -e
          cd /home/deploy/app
          
          # Clean up previous deployment
          docker compose -f docker-compose.prod.yml down -v || true
          
          # Start Typesense first with health check
          echo "Starting Typesense..."
          docker compose -f docker-compose.prod.yml up -d --build typesense
          
          # Extended wait for Typesense with retries
          echo "Waiting for Typesense to become healthy..."
          for i in {1..10}; do
            if docker compose -f docker-compose.prod.yml exec typesense curl -sf http://localhost:8108/health; then
              echo "Typesense is healthy!"
              break
            fi
            echo "Attempt $i/10 - Typesense not ready yet..."
            sleep 10
            if [ $i -eq 10 ]; then
              echo "Typesense failed to become healthy"
              exit 1
            fi
          done
          
          # Start backend with extended health check
          echo "Starting Backend..."
          docker compose -f docker-compose.prod.yml up -d --build backend
          
          echo "Waiting for backend to become healthy..."
          for i in {1..15}; do
            if docker compose -f docker-compose.prod.yml exec backend curl -sf http://localhost:8000/health; then
              echo "Backend is healthy!"
              break
            fi
            echo "Attempt $i/15 - Backend not ready yet..."
            sleep 10
            if [ $i -eq 15 ]; then
              echo "Backend failed to become healthy"
              docker compose -f docker-compose.prod.yml logs backend
              exit 1
            fi
          done
          
          # Start remaining services
          echo "Starting all remaining services..."
          docker compose -f docker-compose.prod.yml up -d
          
          echo "=== Deployment Status ==="
          docker compose -f docker-compose.prod.yml ps
          EOT

      - name: Set up SSL certificates
        run: |
          ssh -T -o StrictHostKeyChecking=no deploy@${{ secrets.HETZNER_SERVER_IP }} << 'EOT'
          set -ex
          cd /home/deploy/app

          # 1. Configure IPv4 preference (with sudo fallback)
          echo "Configuring network preferences..."
          echo 'precedence ::ffff:0:0/96  100' | sudo tee -a /etc/gai.conf >/dev/null || true

          # 2. Verify network connectivity
          echo "Checking network configuration..."
          PUBLIC_IP=$(curl -4 -s ifconfig.me)
          echo "Server Public IP: $PUBLIC_IP"
          DOMAIN_IP=$(dig +short A ${{ secrets.PROD_DOMAIN }} | tail -n1)
          
          if [ "$PUBLIC_IP" != "$DOMAIN_IP" ]; then
            echo "❌ DNS mismatch! ${{ secrets.PROD_DOMAIN }} points to $DOMAIN_IP but server IP is $PUBLIC_IP"
            exit 1
          fi

          # 3. Verify port 80 accessibility
          echo "Testing external port 80 access..."
          if ! timeout 3 nc -z $PUBLIC_IP 80; then
            echo "❌ Port 80 not accessible from internet!"
            echo "Checking firewall:"
            sudo ufw status verbose
            echo "Checking Hetzner Cloud firewall rules..."
            if command -v hcloud >/dev/null; then
              hcloud firewall list
            fi
            exit 1
          fi

          # 4. Prepare environment
          echo "Preparing SSL environment..."
          sudo mkdir -p app_data/certbot/{conf,www}
          sudo chown -R deploy:docker app_data/certbot
          sudo find app_data/certbot -type d -exec chmod 775 {} \;
          sudo find app_data/certbot -type f -exec chmod 664 {} \;

          # 5. Free port 80
          echo "Stopping services using port 80..."
          sudo docker compose -f docker-compose.prod.yml stop nginx || true
          sudo pkill -f 'nginx|apache|httpd' || true
          sleep 3
          
          if sudo ss -tulpn | grep ':80'; then
            echo "❌ Port 80 still in use by:"
            sudo ss -tulpn | grep ':80'
            exit 1
          fi

          # 6. Run Certbot with host networking
          echo "Running Certbot (attempt 1/3)..."
          MAX_RETRIES=3
          for i in $(seq 1 $MAX_RETRIES); do
            sudo docker compose -f docker-compose.prod.yml run --rm \
              --service-ports \
              --network host \
              certbot \
              certonly \
              --standalone \
              --non-interactive \
              --agree-tos \
              --email ${{ secrets.PROD_EMAIL }} \
              -d ${{ secrets.PROD_DOMAIN }} \
              -d www.${{ secrets.PROD_DOMAIN }} \
              --preferred-challenges http \
              --http-01-port 80 \
              --debug-challenges && break
              
            if [ $i -lt $MAX_RETRIES ]; then
              echo "⚠️ Attempt $i failed, retrying in 10 seconds..."
              sleep 10
            else
              echo "❌ Certbot failed after $MAX_RETRIES attempts"
              echo "=== Certbot logs ==="
              sudo docker compose -f docker-compose.prod.yml logs certbot
              echo "=== Let's Encrypt logs ==="
              sudo cat /var/log/letsencrypt/letsencrypt.log | tail -n 50
              exit 1
            fi
          done

          # 7. Set permissions and restart
          echo "Finalizing setup..."
          sudo chown -R root:docker app_data/certbot/conf/
          sudo find app_data/certbot/conf/ -type d -exec chmod 750 {} \;
          sudo find app_data/certbot/conf/ -type f -exec chmod 640 {} \;
          
          sudo docker compose -f docker-compose.prod.yml up -d

          # 8. Cleanup and verify
          sudo sed -i '/precedence ::ffff:0:0\/96  100/d' /etc/gai.conf || true
          
          echo "✅ SSL setup successful!"
          echo "Testing HTTPS access..."
          curl -Isk https://${{ secrets.PROD_DOMAIN }} | head -n 5
          EOT

      - name: Verify deployment
        run: |
          ssh -T -o StrictHostKeyChecking=no deploy@${{ secrets.HETZNER_SERVER_IP }} << 'EOT'
          cd /home/deploy/app
          
          echo "=== Service Status ==="
          docker compose -f docker-compose.prod.yml ps -a
          
          echo "\n=== Health Checks ==="
          echo "Typesense:" $(docker compose -f docker-compose.prod.yml exec typesense curl -sf http://localhost:8108/health || echo "unreachable")
          echo "Backend:" $(docker compose -f docker-compose.prod.yml exec backend curl -sf http://localhost:8000/health || echo "unreachable")
          
          echo "\n=== HTTPS Test ==="
          curl -Isk https://${{ secrets.PROD_DOMAIN }} | head -n 5
          EOT
