# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [main]

env:
  PROJECT_DIR: /opt/pers
  COMPOSE_FILE: docker-compose.prod.yml

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # === SECURE SSH SETUP ===
      - name: Configure SSH for ed25519
        run: |
          mkdir -p ~/.ssh
          # Add ed25519 host fingerprint
          echo "${{ secrets.HETZNER_SERVER_IP }} ${{ secrets.HETZNER_SERVER_FINGERPRINT }}" >> ~/.ssh/known_hosts
          
          # Write ed25519 private key
          echo "${{ secrets.HETZNER_SSH_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          
          # Verify key type
          ssh-keygen -l -f ~/.ssh/id_ed25519 | grep -q "ED25519" || (echo "ERROR: Not an ED25519 key"; exit 1)
          
          # Test connection
          ssh -o BatchMode=yes -i ~/.ssh/id_ed25519 deploy@${{ secrets.HETZNER_SERVER_IP }} exit

      # === DEPLOY CODE ===
      - name: Rsync code to server
        run: |
          rsync -avz --delete \
            -e "ssh -i ~/.ssh/id_ed25519 -o IdentitiesOnly=yes" \
            --exclude=".git" \
            --exclude=".github" \
            --exclude="node_modules" \
            --exclude=".env" \
            --exclude="data" \
            --exclude="*.pyc" \
            --exclude="__pycache__" \
            ./ deploy@${{ secrets.HETZNER_SERVER_IP }}:$PROJECT_DIR/

      # === SERVER SETUP ===
      - name: Prepare server environment
        run: |
          ssh -i ~/.ssh/id_ed25519 deploy@${{ secrets.HETZNER_SERVER_IP }} << 'ENDSSH'
            set -euo pipefail
            cd $PROJECT_DIR
            
            # Create necessary directories
            mkdir -p data/typesense data/certbot/{conf,www} nginx/snippets
            chmod -R 755 data
            
            # Create or update .env file
            cat << EOF > .env
            # Backend
            PROD_BACKEND_PORT=${{ secrets.PROD_BACKEND_PORT }}
            PROD_BACKEND_PYTHONPATH=${{ secrets.PROD_BACKEND_PYTHONPATH }}
            
            # Frontend
            PROD_FRONTEND_PORT=${{ secrets.PROD_FRONTEND_PORT }}
            PROD_FRONTEND_PYTHONPATH=${{ secrets.PROD_FRONTEND_PYTHONPATH }}
            
            # Typesense
            PROD_TYPESENSE_API_KEY=${{ secrets.PROD_TYPESENSE_API_KEY }}
            PROD_TYPESENSE_DATA_DIR=${{ secrets.PROD_TYPESENSE_DATA_DIR }}
            PROD_TYPESENSE_HOST=typesense
            PROD_TYPESENSE_PORT=8108
            EOF
            
            chmod 600 .env
          ENDSSH

      # === DEPLOY SERVICES ===
      - name: Build and deploy containers
        run: |
          ssh -i ~/.ssh/id_ed25519 deploy@${{ secrets.HETZNER_SERVER_IP }} << 'ENDSSH'
            set -euo pipefail
            cd $PROJECT_DIR
            
            # Stop existing containers
            docker-compose -f $COMPOSE_FILE down --remove-orphans || true
            
            # Build fresh containers
            docker-compose -f $COMPOSE_FILE build --no-cache
            
            # Handle Let's Encrypt
            if [ ! -d "data/certbot/conf/live" ]; then
              echo "Initializing Let's Encrypt..."
              chmod +x init-letsencrypt.sh
              ./init-letsencrypt.sh
            else
              echo "Starting existing services..."
              docker-compose -f $COMPOSE_FILE up -d --force-recreate
              docker-compose -f $COMPOSE_FILE run --rm certbot renew --dry-run
            fi
          ENDSSH

      # === VERIFICATION ===
      - name: Verify deployment
        run: |
          ssh -i ~/.ssh/id_ed25519 deploy@${{ secrets.HETZNER_SERVER_IP }} << 'ENDSSH'
            set -euo pipefail
            cd $PROJECT_DIR
            
            # Container status check
            running_containers=$(docker-compose -f $COMPOSE_FILE ps -q | wc -l)
            [ "$running_containers" -ge 3 ] || {
              echo "ERROR: Missing containers (expected 3+, got $running_containers)"
              docker-compose -f $COMPOSE_FILE logs
              exit 1
            }
            
            # Service health checks
            declare -A endpoints=(
              ["backend"]="http://localhost:${{ secrets.PROD_BACKEND_PORT }}/health"
              ["frontend"]="http://localhost:${{ secrets.PROD_FRONTEND_PORT }}/health"
            )
            
            for service in "${!endpoints[@]}"; do
              echo "Testing $service health..."
              curl -fsS --retry 3 --max-time 5 "${endpoints[$service]}" || {
                echo "HEALTH CHECK FAILED: $service"
                exit 1
              }
            done
          ENDSSH

      # === CLEANUP ===
      - name: Clean up old containers
        if: always()
        run: |
          # Set up SSH environment from scratch
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Create known_hosts with proper formatting
          {
            echo "Host ${{ secrets.HETZNER_SERVER_IP }}"
            echo "  HostName ${{ secrets.HETZNER_SERVER_IP }}"
            echo "  User deploy"
            echo "  IdentityFile ~/.ssh/id_ed25519"
            echo "  StrictHostKeyChecking yes"
            echo "  UserKnownHostsFile ~/.ssh/known_hosts"
            echo "${{ secrets.HETZNER_SERVER_IP }} ${{ secrets.HETZNER_SERVER_FINGERPRINT }}"
          } > ~/.ssh/config
          
          echo "${{ secrets.HETZNER_SERVER_FINGERPRINT }}" > ~/.ssh/known_hosts
          echo "${{ secrets.HETZNER_SSH_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/{config,known_hosts,id_ed25519}
          
          # Test connection first
          if ! ssh -T -F ~/.ssh/config ${{ secrets.HETZNER_SERVER_IP }} echo "Connection test successful"; then
            echo "::error::SSH connection failed"
            exit 1
          fi
          
          # Execute cleanup commands
          ssh -T -F ~/.ssh/config ${{ secrets.HETZNER_SERVER_IP }} <<'EOF'
            set -ex
            echo "Starting cleanup..."
            docker container prune -f
            docker image prune -af
            echo "Cleanup complete"
          EOF
