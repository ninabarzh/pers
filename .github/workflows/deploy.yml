# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [main]

env:
  PROJECT_DIR: /opt/pers
  COMPOSE_FILE: docker-compose.prod.yml

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # === SSH SETUP ===
      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.HETZNER_SERVER_IP }} ${{ secrets.HETZNER_SERVER_FINGERPRINT }}" > ~/.ssh/known_hosts
          echo "${{ secrets.HETZNER_SSH_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519

      # === DEPLOY CODE ===
      - name: Rsync code to server
        run: |
          rsync -avz --delete \
            -e "ssh -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=yes" \
            --exclude=".git" \
            --exclude=".github" \
            --exclude="node_modules" \
            --exclude=".env" \
            --exclude="data" \
            --exclude="*.pyc" \
            --exclude="__pycache__" \
            ./ deploy@${{ secrets.HETZNER_SERVER_IP }}:${{ env.PROJECT_DIR }}/

      # === SERVER SETUP ===
      - name: Initialize server
        run: |
          ssh -i ~/.ssh/id_ed25519 deploy@${{ secrets.HETZNER_SERVER_IP }} <<EOF
            set -euxo pipefail
            cd ${{ env.PROJECT_DIR }} || { echo "ERROR: Failed to access ${{ env.PROJECT_DIR }}"; exit 1; }
            
            # Create directory structure
            mkdir -p data/{typesense,certbot/{conf,www}} nginx/snippets
            chmod -R 755 data
            
            # Create .env file with secure permissions
            umask 077
            cat > .env <<'CONFIG'
            # Backend
            PROD_BACKEND_PORT=${{ secrets.PROD_BACKEND_PORT }}
            PROD_BACKEND_PYTHONPATH=${{ secrets.PROD_BACKEND_PYTHONPATH }}
            
            # Frontend
            PROD_FRONTEND_PORT=${{ secrets.PROD_FRONTEND_PORT }}
            PROD_FRONTEND_PYTHONPATH=${{ secrets.PROD_FRONTEND_PYTHONPATH }}
            
            # Typesense
            PROD_TYPESENSE_API_KEY=${{ secrets.PROD_TYPESENSE_API_KEY }}
            PROD_TYPESENSE_DATA_DIR=${{ secrets.PROD_TYPESENSE_DATA_DIR }}
            PROD_TYPESENSE_HOST=typesense
            PROD_TYPESENSE_PORT=8108
            CONFIG
          EOF

      # === DEPLOY SERVICES ===
      - name: Start containers
        run: |
          ssh -i ~/.ssh/id_ed25519 deploy@${{ secrets.HETZNER_SERVER_IP }} <<EOF
            set -euxo pipefail
            cd ${{ env.PROJECT_DIR }} || exit 1
            
            # Stop any running containers
            docker-compose -f ${{ env.COMPOSE_FILE }} down --remove-orphans || true
            
            # Build and start
            docker-compose -f ${{ env.COMPOSE_FILE }} build --no-cache
            docker-compose -f ${{ env.COMPOSE_FILE }} up -d
            
            # Handle Let's Encrypt
            if [ -d "data/certbot/conf/live" ]; then
              docker-compose -f ${{ env.COMPOSE_FILE }} run --rm certbot renew --dry-run
            else
              echo "No existing Let's Encrypt certificates found"
            fi
          EOF

      # === VERIFICATION ===
      - name: Verify deployment
        run: |
          ssh -i ~/.ssh/id_ed25519 deploy@${{ secrets.HETZNER_SERVER_IP }} <<EOF
            set -euo pipefail
            cd ${{ env.PROJECT_DIR }} || exit 1
            
            # Check running containers
            if ! docker-compose -f ${{ env.COMPOSE_FILE }} ps | grep -q "Up"; then
              echo "ERROR: No containers running"
              docker-compose -f ${{ env.COMPOSE_FILE }} logs
              exit 1
            fi
            
            # Health checks
            check_health() {
              local port=\$1
              if ! curl -fsS "http://localhost:\$port/health"; then
                echo "Health check failed for port \$port"
                exit 1
              fi
            }
            
            check_health ${{ secrets.PROD_BACKEND_PORT }}
            check_health ${{ secrets.PROD_FRONTEND_PORT }}
          EOF
          
      # === CLEANUP ===
      # Removes __pycache__ directories
      # Deletes compiled .pyc files
      # Handles log rotation (adjusts ./logs to log location)
      # Cleans old static files (30+ days)
      # Runs inside the backend container
      # Removes old snapshots (7+ days)
      # Maintains search performance
      # All commands include error handling (|| true)
      # Clear section headers in output
      # Final resource summary
      - name: Cleanup resources
        if: always()
        run: |
          ssh -i ~/.ssh/id_ed25519 deploy@${{ secrets.HETZNER_SERVER_IP }} <<'EOF'
            set -euo pipefail
            echo "=== Starting Starlette Application Cleanup ==="
            
            # 1. Docker cleanup
            echo "- Pruning Docker resources..."
            docker system prune -af --filter "until=24h" --volumes || \
              echo "Docker cleanup completed with warnings"
            
            # 2. Starlette-specific cleanup
            echo "- Cleaning Python/Starlette artifacts..."
            cd ${{ env.PROJECT_DIR }}
            
            # Clear Python caches
            find . -type d -name "__pycache__" -exec rm -rf {} + || true
            find . -type f -name "*.pyc" -delete || true
            
            # Rotate Starlette logs (adjust path as needed)
            find ./logs -name "*.log" -mtime +7 -delete 2>/dev/null || true
            
            # 3. Static files cleanup (if using static volume)
            echo "- Cleaning old static files..."
            docker-compose exec -T backend \
              find /app/static -type f -mtime +30 -delete 2>/dev/null || true
            
            # 4. Typesense cleanup (from your stack)
            echo "- Optimizing Typesense..."
            docker-compose exec -T typesense \
              find /data -name "*.snapshot" -mtime +7 -delete 2>/dev/null || true
            
            echo "=== Cleanup Summary ==="
            echo "Disk usage: $(df -h / | awk 'NR==2{print $5}')"
            echo "Docker space: $(docker system df --format '{{.TotalSpace}}')"
          EOF
